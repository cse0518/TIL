___
# 코딩테스트 관련 정리
<br>

## INDEX
  - [그리디 알고리즘](#그리디-알고리즘)
  - [구현 문제](#구현-문제)
  - [스택 구현 (Python & Java)](#스택-구현python--java)
  - [큐 구현 (Python & Java)](#큐-구현python--java)
  - [재귀 함수](#재귀-함수)
    - 팩토리얼 구현
    - 최대공약수 구현
  - [DFS (Python & Java)](#dfs-depth-first-search)
  - [BFS (Python & Java)](#bfs-breadth-first-search)
  - [정렬 알고리즘](#정렬-알고리즘)
    - 알고리즘 비교(선택, 삽입, 퀵, 계수)
    - 퀵 정렬(상세 과정 & 구현)
    - 계수 정렬(상세 과정 & 구현)
  - [이진 탐색](#이진-탐색)
  - [다이나믹 프로그래밍](#다이나믹-프로그래밍)
___
## 그리디 알고리즘
<br>

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 정당성 분석 중요
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
___
## 구현 문제
<br>

- 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
  - 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
  - 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
  - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
  - 적절한 라이브러리를 찾아서 사용해야 하는 문제
___
## 스택 구현(Python & Java)
<br>
<details>
<summary>Python 스택 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# python은 따로 라이브러리가 필요하지 않음
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(4)

print(stack[::-1]) # 최상단 원소부터 출력
print(stack) # 최하단 원소부터 출력
```
```python
[4, 3, 2, 5]
[5, 2, 3, 4]
```

</div>
</details>
<br>

<details>
<summary>Java 스택 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Stack<Integer> s = new Stack<>();

    s.push(5);
    s.push(2);
    s.push(3);
    s.push(7);
    s.pop();
    s.push(4);

    // 스택의 최상단 원소부터 출력
    while (!s.empty()) {
      System.out.print(s.peek() + "");
      s.pop();
    }
  }
}
```
```java
4 3 2 5
```

</div>
</details>

___
## 큐 구현(Python & Java)
<br>
<details>
<summary>Python 큐 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# list로 바로 구현 가능하지만 시간 복잡도가 높아서 deque 라이브러리 사용 추천
from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(4)
queue.append(1)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 역순으로 바꾸기
print(queue) # 나중에 들어온 순서대로 출력
```
```python
deque([3, 7, 4, 1])
deque([1, 4, 7, 3])
```

</div>
</details>
<br>

<details>
<summary>Java 큐 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Queue<Integer> q = new LinkedList<>();

      q.offer(5);
      q.offer(2);
      q.offer(3);
      q.offer(7);
      q.poll();
      q.offer(4);
      q.offer(1);
      q.poll();

    // 먼저 들어온 원소부터 추출
    while (!q.isEmpty()) {
      System.out.print(q.poll() + "");
    }
  }
}
```
```java
3 7 4 1
```

</div>
</details>

___
## 재귀 함수
<br>

- 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있다.
  - 하지만 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수 있습니다.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓입니다.
  - 그래서 스택을 사용해야 할 때 구현상 스택 라이브러리 대신 재귀 함수를 이용하는 경우가 많습니다.
<br>

<details>
<summary>팩토리얼 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

- n! = 1 x 2 x 3 x ⋯ x (n-1) x n
- 0! = 1! = 1
<br>

```python
# 반복적으로 구현한 n!
def factorial_iterative(n):
  result = 1

  # 1부터 n까지의 수를 차례대로 곱하기
  for i in range(1, n+1):
    result *= i
  
  return result


# 재귀적으로 구현한 n!
def factorial_recursive(n):
  # n이 1 이하인 경우 1을 반환
  if n <= 1:
    return 1
  
  # n! = n * (n-1)!
  return n * factorial_recursive(n-1)

print('반복적으로 구현 결과 :', factorial_iterative(5))
print('재귀적으로 구현 결과 :', factorial_recursive(5))
```
```python
반복적으로 구현 결과 : 120
재귀적으로 구현 결과 : 120
```

</div>
</details>
<br>

<details>
<summary>최대 공약수 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
def gcd(a, b):
  if a % b == 0:
    return b
  else:
    return gcd(b, a% b)

print(gcd(192, 162))
```
```python
6
```

</div>
</details>

___
## DFS (Depth-First Search)
<br>

- 깊이 우선 탐색
- 깊은 부분을 우선적으로 탐색하는 알고리즘
- 스택 자료구조(혹은 재귀 함수)를 이용
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 합니다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리합니다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/126313861-318f5067-b388-4d67-85d1-d89d29748919.png">
<br>

<details>
<summary>Python DFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# DFS 함수 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```
```python
1 2 7 6 8 3 4 5
```

</div>
</details>
<br>

<details>
<summary>Java DFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static boolean[] visited = new boolean[9];
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();

    // DFS 함수 정의
    public static void dfs(int x) {
        // 현재 노드를 방문 처리
        visited[x] = true;
        System.out.print(x + " ");

        // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for (int i = 0; i < graph.get(x).size(); i++) {
            int y = graph.get(x).get(i);
            if (!visited[y]) dfs(y);
        }
    }

    public static void main(String[] args) {
        // 그래프 초기화
        for (int i = 0; i < 9; i++) {
            graph.add(new ArrayList<Integer>());
        }

        // 노드 1에 연결된 노드 정보 저장 
        graph.get(1).add(2);
        graph.get(1).add(3);
        graph.get(1).add(8);
        
        // 노드 2에 연결된 노드 정보 저장 
        graph.get(2).add(1);
        graph.get(2).add(7);
        
        // 노드 3에 연결된 노드 정보 저장 
        graph.get(3).add(1);
        graph.get(3).add(4);
        graph.get(3).add(5);
        
        // 노드 4에 연결된 노드 정보 저장 
        graph.get(4).add(3);
        graph.get(4).add(5);
        
        // 노드 5에 연결된 노드 정보 저장 
        graph.get(5).add(3);
        graph.get(5).add(4);
        
        // 노드 6에 연결된 노드 정보 저장 
        graph.get(6).add(7);
        
        // 노드 7에 연결된 노드 정보 저장 
        graph.get(7).add(2);
        graph.get(7).add(6);
        graph.get(7).add(8);
        
        // 노드 8에 연결된 노드 정보 저장 
        graph.get(8).add(1);
        graph.get(8).add(7);

        dfs(1);
    }
}
```
```java
1 2 7 6 8 3 4 5
```

</div>
</details>

___
## BFS (Breadth-First Search)
<br>

- 너비 우선 탐색
- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- 최단 거리를 구할 때 사용 가능
- 큐 자료구조를 이용
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 바문 처리합니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/126315610-08595bdf-72b5-4573-8a6e-6b7086e8aa1b.JPG">
<br>

<details>
<summary>Python BFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
from collections import deque

# BFS 함수 정의
def bfs(graph, start, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])

    # 현재 노드를 방문 처리
    visited[start] = True

    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        print(v, end=' ')

        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)
```
```python
1 2 3 8 7 4 5 6
```

</div>
</details>
<br>

<details>
<summary>Java BFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static boolean[] visited = new boolean[9];
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();

    // BFS 함수 정의
    public static void bfs(int start) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);

        // 현재 노드를 방문 처리
        visited[start] = true;

        // 큐가 빌 때까지 반복
        while(!q.isEmpty()) {
            // 큐에서 하나의 원소를 뽑아 출력
            int x = q.poll();
            System.out.print(x + " ");

            // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
            for(int i = 0; i < graph.get(x).size(); i++) {
                int y = graph.get(x).get(i);
                if(!visited[y]) {
                    q.offer(y);
                    visited[y] = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        // 그래프 초기화
        for (int i = 0; i < 9; i++) {
            graph.add(new ArrayList<Integer>());
        }

        // 노드 1에 연결된 노드 정보 저장 
        graph.get(1).add(2);
        graph.get(1).add(3);
        graph.get(1).add(8);
        
        // 노드 2에 연결된 노드 정보 저장 
        graph.get(2).add(1);
        graph.get(2).add(7);
        
        // 노드 3에 연결된 노드 정보 저장 
        graph.get(3).add(1);
        graph.get(3).add(4);
        graph.get(3).add(5);
        
        // 노드 4에 연결된 노드 정보 저장 
        graph.get(4).add(3);
        graph.get(4).add(5);
        
        // 노드 5에 연결된 노드 정보 저장 
        graph.get(5).add(3);
        graph.get(5).add(4);
        
        // 노드 6에 연결된 노드 정보 저장 
        graph.get(6).add(7);
        
        // 노드 7에 연결된 노드 정보 저장 
        graph.get(7).add(2);
        graph.get(7).add(6);
        graph.get(7).add(8);
        
        // 노드 8에 연결된 노드 정보 저장 
        graph.get(8).add(1);
        graph.get(8).add(7);

        bfs(1);
    }
}
```
```java
1 2 3 8 7 4 5 6
```

</div>
</details>

___
## 정렬 알고리즘
<br>

- 알고리즘 비교(선택, 삽입, 퀵, 계수)

|정렬 알고리즘| 평균 시간 복잡도| 공간 복잡도| 특징|
|:-----------:|:---------------:|:----------:|-----|
|선택 정렬| O(N²)| O(N)| 아이디어가 간단함|
|삽입 정렬| O(N²)| O(N)| 데이터가 거의 정렬되어 있을때 가장 빠름|
|퀵 정렬| O(NlogN)| O(N)| 대부분의 경우에 적합, 충분히 빠름|
|계수 정렬| O(N+K)| O(N+K)| 데이터의 크기가 한정되어 있는 경우에 적합, 매우 빠름|
<br>

<details>
<summary>퀵 정렬 상세 과정 (펼쳐보기)</summary>
<div markdown="1">
<br>

- 기준 데이터(피벗)을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방식의 정렬
1. 피벗 설정,  
왼쪽부터 피벗보다 큰 데이터 선택,  
오른쪽부터 피벗보다 작은 데이터 선택  
두 개의 데이터 위치 변경,  
계속 반복  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126790023-9b810bd2-a8ce-43f4-b70c-781635aa9fb5.JPG">
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126790024-fde1828b-44f9-4292-9038-cdca73162708.JPG">

##
2. 큰 데이터와 작은 데이터의 위치가 엇갈리는 경우, 피벗과 작은 데이터의 위치 변경  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791094-99ce7c3a-e74f-4850-83a4-559d96e6f395.JPG">

##
3. 피벗을 기준으로 데이터 묶음을 분할  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791099-10b5b4db-14d8-4575-a950-dba262c3f698.JPG">

##
4. 왼쪽 데이터 묶음 퀵 정렬,  
오른쪽 데이터 묶음 퀵 정렬,  
반복  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791101-1d9fcb35-c366-4d6f-b7aa-1ebf63c10558.JPG">
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791104-be5f5ddb-6d56-42a0-9bc5-366f423c6454.JPG">

</div>
</details>
<br>

  <details style="margin-left: 30px">
  <summary>Python 퀵 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```python
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  def quick_sort(array, start, end):
      if start >= end: # 원소가 1개인 경우 종료
          return
      pivot = start # 피벗은 첫 번째 원소
      left = start + 1
      right = end
      while(left <= right):
          # 피벗보다 큰 데이터를 찾을 때까지 반복 
          while(left <= end and array[left] <= array[pivot]):
              left += 1
          # 피벗보다 작은 데이터를 찾을 때까지 반복
          while(right > start and array[right] >= array[pivot]):
              right -= 1
          if(left > right): # 엇갈렸다면 작은 데이터와 피벗을 교체
              array[right], array[pivot] = array[pivot], array[right]
          else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
              array[left], array[right] = array[right], array[left]
      # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
      quick_sort(array, start, right - 1)
      quick_sort(array, right + 1, end)

  quick_sort(array, 0, len(array) - 1)
  print(array)
  ```
  ```python
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```
  <br>

  - 파이썬의 장점을 살린 간결한 코드
  ```python
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  def quick_sort(array):
      # 리스트가 하나 이하의 원소만을 담고 있다면 종료
      if len(array) <= 1:
          return array

      pivot = array[0] # 피벗은 첫 번째 원소
      tail = array[1:] # 피벗을 제외한 리스트

      left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
      right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

      # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
      return quick_sort(left_side) + [pivot] + quick_sort(right_side)

  print(quick_sort(array))
  ```
  ```python
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```

  </div>
  </details>
<br>

  <details style="margin-left: 30px">
  <summary>Java 퀵 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```java
  import java.util.*;

  public class Main {
      public static void quickSort(int[] arr, int start, int end) {
          if (start >= end) return; // 원소가 1개인 경우 종료
          int pivot = start; // 피벗은 첫 번째 원소
          int left = start + 1;
          int right = end;
          while (left <= right) {
              // 피벗보다 큰 데이터를 찾을 때까지 반복
              while (left <= end && arr[left] <= arr[pivot]) left++;

              // 피벗보다 작은 데이터를 찾을 때까지 반복
              while (right > start && arr[right] >= arr[pivot]) right--;

              // 엇갈렸다면 작은 데이터와 피벗을 교체
              if (left > right) {
                  int temp = arr[pivot];
                  arr[pivot] = arr[right];
                  arr[right] = temp;
              }
              // 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
              else {
                  int temp = arr[left];
                  arr[left] = arr[right];
                  arr[right] = temp;
              }
          }
          // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
          quickSort(arr, start, right - 1);
          quickSort(arr, right + 1, end);
      }

      public static void main(String[] args) {
          int n = 10;
          int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

          quickSort(arr, 0, n - 1);

          for(int i = 0; i < n; i++) {
              System.out.print(arr[i] + " ");
          }
      }
  }
  ```
  ```java
  0 1 2 3 4 5 6 7 8 9
  ```

  </div>
  </details>
<br>

<details>
<summary>계수 정렬 상세 과정 (펼쳐보기)</summary>
<div markdown="1">
<br>

- 동일한 값의 데이터가 여러 개 등장할 때 효율적일 것(ex. 시험 성적)

1. 가장 작은 데이터부터 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트 생성
2. 데이터를 하나씩 확인하여 count 1씩 증가
3. count 값 만큼 인덱스 값을 반복 출력  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126797204-9a7b60c5-841e-44ca-b627-ca9eba5606c7.JPG">

</div>
</details>
<br>

  <details style="margin-left: 30px">
  <summary>Python 계수 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```python
  # 모든 원소의 값이 0보다 크거나 같다고 가정
  array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

  # 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)
  count = [0] * (max(array) + 1)

  for i in range(len(array)):
      count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

  for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
      for j in range(count[i]):
          print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
  ```
  ```python
  0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
  ```

  </div>
  </details>
<br>

  <details style="margin-left: 30px">
  <summary>Java 계수 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```java
  import java.util.*;

  public class Main {
      public static final int MAX_VALUE = 9;

      public static void main(String[] args) {
          int n = 15;

          // 모든 원소의 값이 0보다 크거나 같다고 가정
          int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};

          // 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)
          int[] cnt = new int[MAX_VALUE + 1];

          for (int i = 0; i < n; i++) {
              cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가
          }

          for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인
              for (int j = 0; j < cnt[i]; j++) {
                  System.out.print(i + " "); // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력
              }
          }
      }
  }
  ```
  ```java
  0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
  ```

  </div>
  </details>

___
## 이진 탐색
<br>

- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색
- 시작점, 끝점, 중간점을 이용하여 탐색 범위 설정
- 시간복잡도 : logN
<br>

<details>
<summary>Python 이진 탐색 소스코드(재귀 & 반복문)</summary>
<div markdown="1">
<br>

- Python 재귀적 이진 탐색 코드
```python
def binary_search(array, target, start, end):
    if start > end:
        return None

    mid = (start + end) // 2

    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] > target:
        return binary_search(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array, target, mid + 1, end)

# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
n, target = list(map(int, input().split()))

# 전체 원소 입력 받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```
```python
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```
<br>

- Python 반복문을 사용한 이진 탐색 코드
```python
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2

        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1

    return None

# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
n, target = list(map(int, input().split()))

# 전체 원소 입력 받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```
```python
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```

</div>
</details>
<br>

<details>
<summary>Java 이진 탐색 소스코드(재귀 & 반복문)</summary>
<div markdown="1">
<br>

- Java 재귀적 이진 탐색 코드
```java
import java.util.*;

public class Main {
    // 이진 탐색 소스코드 구현(재귀 함수)
    public static int binarySearch(int[] arr, int target, int start, int end) {
        if (start > end) return -1;
        int mid = (start + end) / 2;

        // 찾은 경우 중간점 인덱스 반환
        if (arr[mid] == target) return mid;
        // 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        else if (arr[mid] > target) return binarySearch(arr, target, start, mid - 1);
        // 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else return binarySearch(arr, target, mid + 1, end);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 원소의 개수(n)와 찾고자 하는 값(target)을 입력받기 
        int n = sc.nextInt();
        int target = sc.nextInt();

        // 전체 원소 입력받기 
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // 이진 탐색 수행 결과 출력 
        int result = binarySearch(arr, target, 0, n - 1);
        if (result == -1) {
            System.out.println("원소가 존재하지 않습니다.");
        }
        else {
            System.out.println(result + 1);
        }
    }
}
```
```java
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```
<br>

- Java 반복문을 사용한 이진 탐색 코드
```java
import java.util.*;

public class Main {
    // 이진 탐색 소스코드 구현(반복문)
    public static int binarySearch(int[] arr, int target, int start, int end) {
        while (start <= end) {
            int mid = (start + end) / 2;

            // 찾은 경우 중간점 인덱스 반환
            if (arr[mid] == target) return mid;
            // 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
            else if (arr[mid] > target) end = mid - 1;
            // 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
            else start = mid + 1; 
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 원소의 개수(n)와 찾고자 하는 값(target)을 입력받기 
        int n = sc.nextInt();
        int target = sc.nextInt();

        // 전체 원소 입력받기 
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // 이진 탐색 수행 결과 출력 
        int result = binarySearch(arr, target, 0, n - 1);
        if (result == -1) {
            System.out.println("원소가 존재하지 않습니다.");
        }
        else {
            System.out.println(result + 1);
        }
    }
}
```
```java
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```

</div>
</details>
<br>

- Python 이진 탐색 라이브러리
  - bisect_left(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스 반환
  - bisect_right(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스 반환  
<br>

  ```python
  from bisect import bisect_left, bisect_right

  a = [1, 2, 4, 4, 8]
  x = 4

  print(bisect_left(a, x))
  print(bisect_right(a, x))
  ```
  ```python
  2
  4
  ```
<br>

<details>
<summary>특정 범위에 속하는 데이터 개수 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
from bisect import bisect_left, bisect_right

# 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
def count_by_range(a, left_value, right_value):
  right_index = bisect_right(a, right_value)
  left_index = bisect_left(a, left_value)

  return right_index - left_index

# 배열 선언
a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9]

# 값이 4인 데이터 개수 출력
print(count_by_range(a, 4, 4))

# 값이 [-1, 3] 범위에 있는 데이터 개수 출력
print(count_by_range(a, -1, 3))
```
```python
2
6
```

</div>
</details>
<br>

<details>
<summary>문제 예시 : 떡볶이 떡 만들기 (펼쳐보기)</summary>
<div markdown="1">
<br>

### 떡볶이 떡 만들기
- 길이가 다른 여러개의 떡을 절단기에 넣어 잘린 부분을 가져갑니다.
- 먼저 떡의 개수(M)와 절단기의 높이(h)를 지정합니다.
- 예를 들어 높이가 19cm, 14cm, 10cm, 17cm인 떡이 있고 절단기의 높이가 15cm 라면, 자른 뒤 떡의 높이는 15cm, 14cm, 10cm, 15cm가 될 것입니다. 그리고 잘린 떡의 길이는 차례대로 4cm, 0cm, 0cm, 2cm입니다. 손님은 6cm 만큼의 잘린 떡을 가져갑니다.
- 손님이 요청한 떡의 총 길이가 M 일때, 적어도 M 만큼의 떡을 얻기 위한 절단기 높이(H)의 최댓값을 구하는 프로그램을 작성하세요.

  |입력 예시| 출력 예시|
  |---------|----------|
  |4 6<br/>19 15 10 17| 15|
<br>

### 문제 해결 아이디어
  1. 시작점, 끝점, 중간점을 통한 이진 탐색 진행
  2. 필요한 떡의 크기(M) 이상이면 결과를 저장하고 다음 탐색 진행
  3. 탐색 범위가 더 이상 줄어들지 않을 때까지 반복
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871236-37c294dc-1ab5-4ff1-94f5-39615663ac60.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871240-cf4d3748-3fd7-435c-bf57-543b3767ad20.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871241-e5ae1a57-617f-441a-ac63-a1a18155a7c8.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871243-21380276-46f0-4411-8035-0e2aa066cf6e.JPG">
<br>

<details>
<summary>Python 소스 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# 떡의 개수(N)와 요청한 떡의 길이(M)을 입력
n, m = list(map(int, input().split(' ')))

# 각 떡의 개별 높이 정보를 입력
array = list(map(int, input().split()))

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행 (반복적)
result = 0
while(start <= end):
    total = 0
    mid = (start + end) // 2
    for x in array:
        # 잘랐을 때의 떡볶이 양 계산
        if x > mid:
            total += x - mid

    # 떡볶이 양이 부족한 경우 더 많이 자르기 (오른쪽 부분 탐색)
    if total < m:
        end = mid - 1
    # 떡볶이 양이 충분한 경우 덜 자르기 (왼쪽 부분 탐색)
    else:
        result = mid # 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록
        start = mid + 1

# 정답 출력
print(result)
```
```python
> 4 6
> 19 15 10 17
15
```

</div>
</details>
<br>

<details>
<summary>Java 소스 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 떡의 개수(N)와 요청한 떡의 길이(M)
        int n = sc.nextInt();
        int m = sc.nextInt();

        // 각 떡의 개별 높이 정보 
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // 이진 탐색을 위한 시작점과 끝점 설정
        int start = 0;
        int end = (int) 1e9;

        // 이진 탐색 수행 (반복적)
        int result = 0; 
        while (start <= end) {
            long total = 0;
            int mid = (start + end) / 2;

            for (int i = 0; i < n; i++) {
                // 잘랐을 때의 떡의 양 계산
                if (arr[i] > mid) total += arr[i] - mid; 
            }

            if (total < m) { // 떡의 양이 부족한 경우 더 많이 자르기(왼쪽 부분 탐색)
                end = mid - 1;
            }
            else { // 떡의 양이 충분한 경우 덜 자르기(오른쪽 부분 탐색)
                result = mid; // 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록 
                start = mid + 1;
            }
        }

        System.out.println(result);
    }
}
```
```java
> 4 6
> 19 15 10 17
15
```

</div>
</details>

</div>
</details>

___
## 다이나믹 프로그래밍
<br>

- 동적 계획법
- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법.
- 이미 계산된 결과를 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함.
- 탑다운 or 바텀업 방식

- 다이나믹 프로그래밍 사용 조건
  1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있다.
  2. 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결한다.
- 피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족한다.
- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)이다.

<details>
<summary>피보나치 수열</summary>
<div markdown="1">
<br>

<details>
<summary>Python 피보나치 수열 구현 - 단순 재귀함수 (비효율적)</summary>
<div markdown="1">
<br>

```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```
```python
3
```

</div>
</details>
<br>

<details>
<summary>Python 피보나치 수열 구현 - 탑다운 방식 (효율적)</summary>
<div markdown="1">
<br>

```python
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1

    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]

    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)

    return d[x]

print(fibo(99))
```
```python
218922995834555169026
```

</div>
</details>
<br>

<details>
<summary>Python 피보나치 수열 구현 - 바텀업 방식 (효율적)</summary>
<div markdown="1">
<br>

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```
```python
218922995834555169026
```

</div>
</details>
<br>

<details>
<summary>Java 피보나치 수열 구현 - 탑다운 방식 (효율적)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    // 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 배열 초기화
    public static long[] d = new long[100];

    // 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
    public static long fibo(int x) {
        // 종료 조건(1 혹은 2일 때 1을 반환)
        if (x == 1 || x == 2) {
            return 1;
        }

        // 이미 계산한 적 있는 문제라면 그대로 반환
        if (d[x] != 0) {
            return d[x];
        }

        // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x] = fibo(x - 1) + fibo(x - 2);
        
        return d[x];
    }

    public static void main(String[] args) {
        System.out.println(fibo(50));
    }
}
```
```java
12586269025
```

</div>
</details>
<br>

<details>
<summary>Java 피보나치 수열 구현 - 바텀업 방식 (효율적)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static long[] d = new long[100];

    public static void main(String[] args) {
        // 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
        d[1] = 1;
        d[2] = 1;
        int n = 50; // 50번째 피보나치 수를 계산

        // 피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
        for (int i = 3; i <= n; i++) {
            d[i] = d[i - 1] + d[i - 2];
        }

        System.out.println(d[n]);
    }
}
```
```java
12586269025
```

</div>
</details>
<br>

</div>
</details>
<br>

<details>
<summary>문제 예시 1 : 개미 전사, 식량창고 털기</summary>
<div markdown="1">
<br>

### 개미 전사
- 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 식량창고는 일직선으로 이어져 있다.
- 각 식량창고에는 정해진 수의 식량을 저장하고 있으며, 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 인접한 식량창고가 공격받으면 바로 알아챌 수 있다.
- 따라서 개미 전사가 정찰벼에게 들키지않고 식량창고를 약탈하기 위해서는 `최소한 한칸 이상 떨어진 식량창고를 약탈`해야 한다.

  <img width="600px" src="https://user-images.githubusercontent.com/60170616/127125270-21abe8e4-b9da-4b6f-b177-e399421cb58b.JPG">

  |입력 예시|출력 예시|
  |-|-|
  |4<br/>1 3 1 5|8|
<br>

- 이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다.
- 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때, 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하세요.
<br>

### 문제 해결 아이디어
- i 번째 창고를 털 경우와 털지 않을 경우로 생각
  - i 번째 창고를 털 경우 : i-2 번째 창고까지 턴 경우 중 최대값 + i 번째 창고
  - i 번째 창고를 털지 않을 경우 : i-1 번째 창고까지 턴 경우 중 최댓값
<br>

<details>
<summary>Python 소스 코드</summary>
<div markdown="1">
<br>

```python
# 정수 N을 입력 받기
n = int(input())

# 모든 식량 정보 입력 받기
array = list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 다이나믹 프로그래밍 진행 (바텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])

for i in range(2, n):
    d[i] = max(d[i - 1], d[i - 2] + array[i])

# 계산된 결과 출력
print(d[n - 1])
```
```python
> 4
> 1 3 1 5
8
```
</div>
</details>
<br>

<details>
<summary>Java 소스 코드</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    // 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 
    public static int[] d = new int[100];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 정수 N을 입력받기
        int n = sc.nextInt();

        // 모든 식량 정보 입력받기
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        
        // 다이나믹 프로그래밍 진행(바텀업)
        d[0] = arr[0];
        d[1] = Math.max(arr[0], arr[1]);

        for (int i = 2; i < n; i++) {
            d[i] = Math.max(d[i - 1], d[i - 2] + arr[i]);
        }

        // 계산된 결과 출력
        System.out.println(d[n - 1]);
    }
}
```
```java
> 4
> 1 3 1 5
8
```
</div>
</details>
<br>

</div>
</details>
<br>

<details>
<summary>문제 예시 2 : 1로 만들기</summary>
<div markdown="1">
<br>

### 1로 만들기
- 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
  1. X가 5로 나누어 떨어지면, 5로 나눕니다.
  2. X가 3으로 나누어 떨어지면, 3으로 나눕니다.
  3. X가 2로 나누어 떨어지면, 2로 나눕니다.
  4. X에서 1을 뺍니다.
- 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값입니다.
  - 26 -> 25 -> 5 -> 1
<br>

  |입력 예시|출력 예시|
  |-|-|
  |26|3|
<br>

### 문제 해결 아이디어
- 4가지 연산 각각의 경우에 다이나믹 프로그래밍을 적용한다.
- 점화식 :  
<img width="500px" src="https://user-images.githubusercontent.com/60170616/127127557-51a857e4-5526-4d0f-a3bd-528d20bee688.JPG">
<br>

<details>
<summary>Python 소스 코드</summary>
<div markdown="1">
<br>

```python
# 정수 X를 입력 받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 1000001

# 다이나믹 프로그래밍 진행(바텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1

    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)

    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)

    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
```
```python
> 26
3
```
</div>
</details>
<br>

<details>
<summary>Java 소스 코드</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    // 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 
    public static int[] d = new int[30001];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int x = sc.nextInt();

        // 다이나믹 프로그래밍 진행(바텀업)
        for (int i = 2; i <= x; i++) {
            // 현재의 수에서 1을 빼는 경우
            d[i] = d[i - 1] + 1;

            // 현재의 수가 2로 나누어 떨어지는 경우
            if (i % 2 == 0)
                d[i] = Math.min(d[i], d[i / 2] + 1);

            // 현재의 수가 3으로 나누어 떨어지는 경우
            if (i % 3 == 0)
                d[i] = Math.min(d[i], d[i / 3] + 1);

            // 현재의 수가 5로 나누어 떨어지는 경우
            if (i % 5 == 0)
                d[i] = Math.min(d[i], d[i / 5] + 1);
        }

        System.out.println(d[x]);
    }
}
```
```java
> 26
3
```
</div>
</details>
<br>

___
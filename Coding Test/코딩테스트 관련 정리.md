___
# 코딩테스트 관련 정리
<br>

## INDEX
  - [그리디 알고리즘](#그리디-알고리즘)
  - [구현 문제](#구현-문제)
  - [스택 구현 (Python & Java)](#스택-구현python--java)
  - [큐 구현 (Python & Java)](#큐-구현python--java)
  - [재귀 함수](#재귀-함수)
    - 팩토리얼 구현
    - 최대공약수 구현
  - [DFS (Python & Java)](#dfs-depth-first-search)
  - [BFS (Python & Java)](#bfs-breadth-first-search)
  - [정렬 알고리즘](#정렬-알고리즘)
    - 알고리즘 비교(선택, 삽입, 퀵, 계수)
    - 퀵 정렬(상세 과정 & 구현)
    - 계수 정렬(상세 과정 & 구현)
  - [이진 탐색](#이진-탐색)
  - [다이나믹 프로그래밍](#다이나믹-프로그래밍)
  - [최단 경로 알고리즘](#최단-경로-알고리즘)
    - 다익스트라 최단 경로 알고리즘
    - 플로이드 워셜 알고리즘
  - [소수(Prime Number)](#소수prime-number)
___
## 그리디 알고리즘
<br>

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 정당성 분석 중요
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
___
## 구현 문제
<br>

- 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
  - 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
  - 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
  - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
  - 적절한 라이브러리를 찾아서 사용해야 하는 문제
___
## 스택 구현(Python & Java)
<br>
<details>
<summary>Python 스택 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# python은 따로 라이브러리가 필요하지 않음
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(4)

print(stack[::-1]) # 최상단 원소부터 출력
print(stack) # 최하단 원소부터 출력
```
```python
[4, 3, 2, 5]
[5, 2, 3, 4]
```

</div>
</details>
<br>

<details>
<summary>Java 스택 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Stack<Integer> s = new Stack<>();

    s.push(5);
    s.push(2);
    s.push(3);
    s.push(7);
    s.pop();
    s.push(4);

    // 스택의 최상단 원소부터 출력
    while (!s.empty()) {
      System.out.print(s.peek() + "");
      s.pop();
    }
  }
}
```
```java
4 3 2 5
```

</div>
</details>

___
## 큐 구현(Python & Java)
<br>
<details>
<summary>Python 큐 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# list로 바로 구현 가능하지만 시간 복잡도가 높아서 deque 라이브러리 사용 추천
from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(4)
queue.append(1)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 역순으로 바꾸기
print(queue) # 나중에 들어온 순서대로 출력
```
```python
deque([3, 7, 4, 1])
deque([1, 4, 7, 3])
```

</div>
</details>
<br>

<details>
<summary>Java 큐 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Queue<Integer> q = new LinkedList<>();

      q.offer(5);
      q.offer(2);
      q.offer(3);
      q.offer(7);
      q.poll();
      q.offer(4);
      q.offer(1);
      q.poll();

    // 먼저 들어온 원소부터 추출
    while (!q.isEmpty()) {
      System.out.print(q.poll() + "");
    }
  }
}
```
```java
3 7 4 1
```

</div>
</details>

___
## 재귀 함수
<br>

- 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있다.
  - 하지만 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수 있습니다.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓입니다.
  - 그래서 스택을 사용해야 할 때 구현상 스택 라이브러리 대신 재귀 함수를 이용하는 경우가 많습니다.
<br>

<details>
<summary>팩토리얼 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

- n! = 1 x 2 x 3 x ⋯ x (n-1) x n
- 0! = 1! = 1
<br>

```python
# 반복적으로 구현한 n!
def factorial_iterative(n):
  result = 1

  # 1부터 n까지의 수를 차례대로 곱하기
  for i in range(1, n+1):
    result *= i
  
  return result


# 재귀적으로 구현한 n!
def factorial_recursive(n):
  # n이 1 이하인 경우 1을 반환
  if n <= 1:
    return 1
  
  # n! = n * (n-1)!
  return n * factorial_recursive(n-1)

print('반복적으로 구현 결과 :', factorial_iterative(5))
print('재귀적으로 구현 결과 :', factorial_recursive(5))
```
```python
반복적으로 구현 결과 : 120
재귀적으로 구현 결과 : 120
```

</div>
</details>
<br>

<details>
<summary>최대 공약수 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
def gcd(a, b):
  if a % b == 0:
    return b
  else:
    return gcd(b, a% b)

print(gcd(192, 162))
```
```python
6
```

</div>
</details>

___
## DFS (Depth-First Search)
<br>

- 깊이 우선 탐색
- 깊은 부분을 우선적으로 탐색하는 알고리즘
- 스택 자료구조(혹은 재귀 함수)를 이용
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 합니다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리합니다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/126313861-318f5067-b388-4d67-85d1-d89d29748919.png">
<br>

<details>
<summary>Python DFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# DFS 함수 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```
```python
1 2 7 6 8 3 4 5
```

</div>
</details>
<br>

<details>
<summary>Java DFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static boolean[] visited = new boolean[9];
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();

    // DFS 함수 정의
    public static void dfs(int x) {
        // 현재 노드를 방문 처리
        visited[x] = true;
        System.out.print(x + " ");

        // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for (int i = 0; i < graph.get(x).size(); i++) {
            int y = graph.get(x).get(i);
            if (!visited[y]) dfs(y);
        }
    }

    public static void main(String[] args) {
        // 그래프 초기화
        for (int i = 0; i < 9; i++) {
            graph.add(new ArrayList<Integer>());
        }

        // 노드 1에 연결된 노드 정보 저장 
        graph.get(1).add(2);
        graph.get(1).add(3);
        graph.get(1).add(8);
        
        // 노드 2에 연결된 노드 정보 저장 
        graph.get(2).add(1);
        graph.get(2).add(7);
        
        // 노드 3에 연결된 노드 정보 저장 
        graph.get(3).add(1);
        graph.get(3).add(4);
        graph.get(3).add(5);
        
        // 노드 4에 연결된 노드 정보 저장 
        graph.get(4).add(3);
        graph.get(4).add(5);
        
        // 노드 5에 연결된 노드 정보 저장 
        graph.get(5).add(3);
        graph.get(5).add(4);
        
        // 노드 6에 연결된 노드 정보 저장 
        graph.get(6).add(7);
        
        // 노드 7에 연결된 노드 정보 저장 
        graph.get(7).add(2);
        graph.get(7).add(6);
        graph.get(7).add(8);
        
        // 노드 8에 연결된 노드 정보 저장 
        graph.get(8).add(1);
        graph.get(8).add(7);

        dfs(1);
    }
}
```
```java
1 2 7 6 8 3 4 5
```

</div>
</details>

___
## BFS (Breadth-First Search)
<br>

- 너비 우선 탐색
- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- 최단 거리를 구할 때 사용 가능
- 큐 자료구조를 이용
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 바문 처리합니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/126315610-08595bdf-72b5-4573-8a6e-6b7086e8aa1b.JPG">
<br>

<details>
<summary>Python BFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
from collections import deque

# BFS 함수 정의
def bfs(graph, start, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])

    # 현재 노드를 방문 처리
    visited[start] = True

    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        print(v, end=' ')

        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)
```
```python
1 2 3 8 7 4 5 6
```

</div>
</details>
<br>

<details>
<summary>Java BFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static boolean[] visited = new boolean[9];
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();

    // BFS 함수 정의
    public static void bfs(int start) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);

        // 현재 노드를 방문 처리
        visited[start] = true;

        // 큐가 빌 때까지 반복
        while(!q.isEmpty()) {
            // 큐에서 하나의 원소를 뽑아 출력
            int x = q.poll();
            System.out.print(x + " ");

            // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
            for(int i = 0; i < graph.get(x).size(); i++) {
                int y = graph.get(x).get(i);
                if(!visited[y]) {
                    q.offer(y);
                    visited[y] = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        // 그래프 초기화
        for (int i = 0; i < 9; i++) {
            graph.add(new ArrayList<Integer>());
        }

        // 노드 1에 연결된 노드 정보 저장 
        graph.get(1).add(2);
        graph.get(1).add(3);
        graph.get(1).add(8);
        
        // 노드 2에 연결된 노드 정보 저장 
        graph.get(2).add(1);
        graph.get(2).add(7);
        
        // 노드 3에 연결된 노드 정보 저장 
        graph.get(3).add(1);
        graph.get(3).add(4);
        graph.get(3).add(5);
        
        // 노드 4에 연결된 노드 정보 저장 
        graph.get(4).add(3);
        graph.get(4).add(5);
        
        // 노드 5에 연결된 노드 정보 저장 
        graph.get(5).add(3);
        graph.get(5).add(4);
        
        // 노드 6에 연결된 노드 정보 저장 
        graph.get(6).add(7);
        
        // 노드 7에 연결된 노드 정보 저장 
        graph.get(7).add(2);
        graph.get(7).add(6);
        graph.get(7).add(8);
        
        // 노드 8에 연결된 노드 정보 저장 
        graph.get(8).add(1);
        graph.get(8).add(7);

        bfs(1);
    }
}
```
```java
1 2 3 8 7 4 5 6
```

</div>
</details>

___
## 정렬 알고리즘
<br>

- 알고리즘 비교(선택, 삽입, 퀵, 계수)

|정렬 알고리즘| 평균 시간 복잡도| 공간 복잡도| 특징|
|:-----------:|:---------------:|:----------:|-----|
|선택 정렬| O(N²)| O(N)| 아이디어가 간단함|
|삽입 정렬| O(N²)| O(N)| 데이터가 거의 정렬되어 있을때 가장 빠름|
|퀵 정렬| O(NlogN)| O(N)| 대부분의 경우에 적합, 충분히 빠름|
|계수 정렬| O(N+K)| O(N+K)| 데이터의 크기가 한정되어 있는 경우에 적합, 매우 빠름|
<br>

<details>
<summary>퀵 정렬 상세 과정 (펼쳐보기)</summary>
<div markdown="1">
<br>

- 기준 데이터(피벗)을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방식의 정렬
1. 피벗 설정,  
왼쪽부터 피벗보다 큰 데이터 선택,  
오른쪽부터 피벗보다 작은 데이터 선택  
두 개의 데이터 위치 변경,  
계속 반복  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126790023-9b810bd2-a8ce-43f4-b70c-781635aa9fb5.JPG">
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126790024-fde1828b-44f9-4292-9038-cdca73162708.JPG">

##
2. 큰 데이터와 작은 데이터의 위치가 엇갈리는 경우, 피벗과 작은 데이터의 위치 변경  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791094-99ce7c3a-e74f-4850-83a4-559d96e6f395.JPG">

##
3. 피벗을 기준으로 데이터 묶음을 분할  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791099-10b5b4db-14d8-4575-a950-dba262c3f698.JPG">

##
4. 왼쪽 데이터 묶음 퀵 정렬,  
오른쪽 데이터 묶음 퀵 정렬,  
반복  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791101-1d9fcb35-c366-4d6f-b7aa-1ebf63c10558.JPG">
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791104-be5f5ddb-6d56-42a0-9bc5-366f423c6454.JPG">

</div>
</details>
<br>

  <details style="margin-left: 30px">
  <summary>Python 퀵 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```python
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  def quick_sort(array, start, end):
      if start >= end: # 원소가 1개인 경우 종료
          return
      pivot = start # 피벗은 첫 번째 원소
      left = start + 1
      right = end
      while(left <= right):
          # 피벗보다 큰 데이터를 찾을 때까지 반복 
          while(left <= end and array[left] <= array[pivot]):
              left += 1
          # 피벗보다 작은 데이터를 찾을 때까지 반복
          while(right > start and array[right] >= array[pivot]):
              right -= 1
          if(left > right): # 엇갈렸다면 작은 데이터와 피벗을 교체
              array[right], array[pivot] = array[pivot], array[right]
          else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
              array[left], array[right] = array[right], array[left]
      # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
      quick_sort(array, start, right - 1)
      quick_sort(array, right + 1, end)

  quick_sort(array, 0, len(array) - 1)
  print(array)
  ```
  ```python
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```
  <br>

  - 파이썬의 장점을 살린 간결한 코드
  ```python
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

  def quick_sort(array):
      # 리스트가 하나 이하의 원소만을 담고 있다면 종료
      if len(array) <= 1:
          return array

      pivot = array[0] # 피벗은 첫 번째 원소
      tail = array[1:] # 피벗을 제외한 리스트

      left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
      right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

      # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
      return quick_sort(left_side) + [pivot] + quick_sort(right_side)

  print(quick_sort(array))
  ```
  ```python
  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```

  </div>
  </details>
<br>

  <details style="margin-left: 30px">
  <summary>Java 퀵 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```java
  import java.util.*;

  public class Main {
      public static void quickSort(int[] arr, int start, int end) {
          if (start >= end) return; // 원소가 1개인 경우 종료
          int pivot = start; // 피벗은 첫 번째 원소
          int left = start + 1;
          int right = end;
          while (left <= right) {
              // 피벗보다 큰 데이터를 찾을 때까지 반복
              while (left <= end && arr[left] <= arr[pivot]) left++;

              // 피벗보다 작은 데이터를 찾을 때까지 반복
              while (right > start && arr[right] >= arr[pivot]) right--;

              // 엇갈렸다면 작은 데이터와 피벗을 교체
              if (left > right) {
                  int temp = arr[pivot];
                  arr[pivot] = arr[right];
                  arr[right] = temp;
              }
              // 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
              else {
                  int temp = arr[left];
                  arr[left] = arr[right];
                  arr[right] = temp;
              }
          }
          // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
          quickSort(arr, start, right - 1);
          quickSort(arr, right + 1, end);
      }

      public static void main(String[] args) {
          int n = 10;
          int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

          quickSort(arr, 0, n - 1);

          for(int i = 0; i < n; i++) {
              System.out.print(arr[i] + " ");
          }
      }
  }
  ```
  ```java
  0 1 2 3 4 5 6 7 8 9
  ```

  </div>
  </details>
<br>

<details>
<summary>계수 정렬 상세 과정 (펼쳐보기)</summary>
<div markdown="1">
<br>

- 동일한 값의 데이터가 여러 개 등장할 때 효율적일 것(ex. 시험 성적)

1. 가장 작은 데이터부터 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트 생성
2. 데이터를 하나씩 확인하여 count 1씩 증가
3. count 값 만큼 인덱스 값을 반복 출력  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126797204-9a7b60c5-841e-44ca-b627-ca9eba5606c7.JPG">

</div>
</details>
<br>

  <details style="margin-left: 30px">
  <summary>Python 계수 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```python
  # 모든 원소의 값이 0보다 크거나 같다고 가정
  array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

  # 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)
  count = [0] * (max(array) + 1)

  for i in range(len(array)):
      count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

  for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
      for j in range(count[i]):
          print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
  ```
  ```python
  0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
  ```

  </div>
  </details>
<br>

  <details style="margin-left: 30px">
  <summary>Java 계수 정렬 구현 코드 (펼쳐보기)</summary>
  <div markdown="1">
  <br>

  ```java
  import java.util.*;

  public class Main {
      public static final int MAX_VALUE = 9;

      public static void main(String[] args) {
          int n = 15;

          // 모든 원소의 값이 0보다 크거나 같다고 가정
          int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};

          // 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)
          int[] cnt = new int[MAX_VALUE + 1];

          for (int i = 0; i < n; i++) {
              cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가
          }

          for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인
              for (int j = 0; j < cnt[i]; j++) {
                  System.out.print(i + " "); // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력
              }
          }
      }
  }
  ```
  ```java
  0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
  ```

  </div>
  </details>

___
## 이진 탐색
<br>

- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색
- 시작점, 끝점, 중간점을 이용하여 탐색 범위 설정
- 시간복잡도 : logN
<br>

<details>
<summary>Python 이진 탐색 소스코드(재귀 & 반복문)</summary>
<div markdown="1">
<br>

- Python 재귀적 이진 탐색 코드
```python
def binary_search(array, target, start, end):
    if start > end:
        return None

    mid = (start + end) // 2

    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] > target:
        return binary_search(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array, target, mid + 1, end)

# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
n, target = list(map(int, input().split()))

# 전체 원소 입력 받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```
```python
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```
<br>

- Python 반복문을 사용한 이진 탐색 코드
```python
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2

        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1

    return None

# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
n, target = list(map(int, input().split()))

# 전체 원소 입력 받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```
```python
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```

</div>
</details>
<br>

<details>
<summary>Java 이진 탐색 소스코드(재귀 & 반복문)</summary>
<div markdown="1">
<br>

- Java 재귀적 이진 탐색 코드
```java
import java.util.*;

public class Main {
    // 이진 탐색 소스코드 구현(재귀 함수)
    public static int binarySearch(int[] arr, int target, int start, int end) {
        if (start > end) return -1;
        int mid = (start + end) / 2;

        // 찾은 경우 중간점 인덱스 반환
        if (arr[mid] == target) return mid;
        // 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        else if (arr[mid] > target) return binarySearch(arr, target, start, mid - 1);
        // 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else return binarySearch(arr, target, mid + 1, end);
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 원소의 개수(n)와 찾고자 하는 값(target)을 입력받기 
        int n = sc.nextInt();
        int target = sc.nextInt();

        // 전체 원소 입력받기 
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // 이진 탐색 수행 결과 출력 
        int result = binarySearch(arr, target, 0, n - 1);
        if (result == -1) {
            System.out.println("원소가 존재하지 않습니다.");
        }
        else {
            System.out.println(result + 1);
        }
    }
}
```
```java
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```
<br>

- Java 반복문을 사용한 이진 탐색 코드
```java
import java.util.*;

public class Main {
    // 이진 탐색 소스코드 구현(반복문)
    public static int binarySearch(int[] arr, int target, int start, int end) {
        while (start <= end) {
            int mid = (start + end) / 2;

            // 찾은 경우 중간점 인덱스 반환
            if (arr[mid] == target) return mid;
            // 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
            else if (arr[mid] > target) end = mid - 1;
            // 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
            else start = mid + 1; 
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 원소의 개수(n)와 찾고자 하는 값(target)을 입력받기 
        int n = sc.nextInt();
        int target = sc.nextInt();

        // 전체 원소 입력받기 
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // 이진 탐색 수행 결과 출력 
        int result = binarySearch(arr, target, 0, n - 1);
        if (result == -1) {
            System.out.println("원소가 존재하지 않습니다.");
        }
        else {
            System.out.println(result + 1);
        }
    }
}
```
```java
> 10 7
> 1 3 5 7 9 11 13 15 17 19
4
```

</div>
</details>
<br>

- Python 이진 탐색 라이브러리
  - bisect_left(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스 반환
  - bisect_right(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스 반환  
<br>

  ```python
  from bisect import bisect_left, bisect_right

  a = [1, 2, 4, 4, 8]
  x = 4

  print(bisect_left(a, x))
  print(bisect_right(a, x))
  ```
  ```python
  2
  4
  ```
<br>

<details>
<summary>특정 범위에 속하는 데이터 개수 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
from bisect import bisect_left, bisect_right

# 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
def count_by_range(a, left_value, right_value):
  right_index = bisect_right(a, right_value)
  left_index = bisect_left(a, left_value)

  return right_index - left_index

# 배열 선언
a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9]

# 값이 4인 데이터 개수 출력
print(count_by_range(a, 4, 4))

# 값이 [-1, 3] 범위에 있는 데이터 개수 출력
print(count_by_range(a, -1, 3))
```
```python
2
6
```

</div>
</details>
<br>

<details>
<summary>문제 예시 : 떡볶이 떡 만들기 (펼쳐보기)</summary>
<div markdown="1">
<br>

### 떡볶이 떡 만들기
- 길이가 다른 여러개의 떡을 절단기에 넣어 잘린 부분을 가져갑니다.
- 먼저 떡의 개수(M)와 절단기의 높이(h)를 지정합니다.
- 예를 들어 높이가 19cm, 14cm, 10cm, 17cm인 떡이 있고 절단기의 높이가 15cm 라면, 자른 뒤 떡의 높이는 15cm, 14cm, 10cm, 15cm가 될 것입니다. 그리고 잘린 떡의 길이는 차례대로 4cm, 0cm, 0cm, 2cm입니다. 손님은 6cm 만큼의 잘린 떡을 가져갑니다.
- 손님이 요청한 떡의 총 길이가 M 일때, 적어도 M 만큼의 떡을 얻기 위한 절단기 높이(H)의 최댓값을 구하는 프로그램을 작성하세요.

  |입력 예시| 출력 예시|
  |---------|----------|
  |4 6<br/>19 15 10 17| 15|
<br>

### 문제 해결 아이디어
  1. 시작점, 끝점, 중간점을 통한 이진 탐색 진행
  2. 필요한 떡의 크기(M) 이상이면 결과를 저장하고 다음 탐색 진행
  3. 탐색 범위가 더 이상 줄어들지 않을 때까지 반복
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871236-37c294dc-1ab5-4ff1-94f5-39615663ac60.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871240-cf4d3748-3fd7-435c-bf57-543b3767ad20.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871241-e5ae1a57-617f-441a-ac63-a1a18155a7c8.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/126871243-21380276-46f0-4411-8035-0e2aa066cf6e.JPG">
<br>

<details>
<summary>Python 소스 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```python
# 떡의 개수(N)와 요청한 떡의 길이(M)을 입력
n, m = list(map(int, input().split(' ')))

# 각 떡의 개별 높이 정보를 입력
array = list(map(int, input().split()))

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행 (반복적)
result = 0
while(start <= end):
    total = 0
    mid = (start + end) // 2
    for x in array:
        # 잘랐을 때의 떡볶이 양 계산
        if x > mid:
            total += x - mid

    # 떡볶이 양이 부족한 경우 더 많이 자르기 (오른쪽 부분 탐색)
    if total < m:
        end = mid - 1
    # 떡볶이 양이 충분한 경우 덜 자르기 (왼쪽 부분 탐색)
    else:
        result = mid # 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록
        start = mid + 1

# 정답 출력
print(result)
```
```python
> 4 6
> 19 15 10 17
15
```

</div>
</details>
<br>

<details>
<summary>Java 소스 코드 (펼쳐보기)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        // 떡의 개수(N)와 요청한 떡의 길이(M)
        int n = sc.nextInt();
        int m = sc.nextInt();

        // 각 떡의 개별 높이 정보 
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }

        // 이진 탐색을 위한 시작점과 끝점 설정
        int start = 0;
        int end = (int) 1e9;

        // 이진 탐색 수행 (반복적)
        int result = 0; 
        while (start <= end) {
            long total = 0;
            int mid = (start + end) / 2;

            for (int i = 0; i < n; i++) {
                // 잘랐을 때의 떡의 양 계산
                if (arr[i] > mid) total += arr[i] - mid; 
            }

            if (total < m) { // 떡의 양이 부족한 경우 더 많이 자르기(왼쪽 부분 탐색)
                end = mid - 1;
            }
            else { // 떡의 양이 충분한 경우 덜 자르기(오른쪽 부분 탐색)
                result = mid; // 최대한 덜 잘랐을 때가 정답이므로, 여기에서 result에 기록 
                start = mid + 1;
            }
        }

        System.out.println(result);
    }
}
```
```java
> 4 6
> 19 15 10 17
15
```

</div>
</details>

</div>
</details>

___
## 다이나믹 프로그래밍
<br>

- 동적 계획법
- 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법.
- 이미 계산된 결과를 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함.
- 탑다운 or 바텀업 방식

- 다이나믹 프로그래밍 사용 조건
  1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있다.
  2. 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결한다.
- 피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족한다.
- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)이다.
<br>

<details>
<summary>피보나치 수열</summary>
<div markdown="1">
<br>

<details>
<summary>Python 피보나치 수열 구현 - 단순 재귀함수 (비효율적)</summary>
<div markdown="1">
<br>

```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```
```python
3
```

</div>
</details>
<br>

<details>
<summary>Python 피보나치 수열 구현 - 탑다운 방식 (효율적)</summary>
<div markdown="1">
<br>

```python
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1

    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]

    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)

    return d[x]

print(fibo(99))
```
```python
218922995834555169026
```

</div>
</details>
<br>

<details>
<summary>Python 피보나치 수열 구현 - 바텀업 방식 (효율적)</summary>
<div markdown="1">
<br>

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```
```python
218922995834555169026
```

</div>
</details>
<br>

<details>
<summary>Java 피보나치 수열 구현 - 탑다운 방식 (효율적)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    // 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 배열 초기화
    public static long[] d = new long[100];

    // 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
    public static long fibo(int x) {
        // 종료 조건(1 혹은 2일 때 1을 반환)
        if (x == 1 || x == 2) {
            return 1;
        }

        // 이미 계산한 적 있는 문제라면 그대로 반환
        if (d[x] != 0) {
            return d[x];
        }

        // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
        d[x] = fibo(x - 1) + fibo(x - 2);
        
        return d[x];
    }

    public static void main(String[] args) {
        System.out.println(fibo(50));
    }
}
```
```java
12586269025
```

</div>
</details>
<br>

<details>
<summary>Java 피보나치 수열 구현 - 바텀업 방식 (효율적)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    public static long[] d = new long[100];

    public static void main(String[] args) {
        // 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
        d[1] = 1;
        d[2] = 1;
        int n = 50; // 50번째 피보나치 수를 계산

        // 피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
        for (int i = 3; i <= n; i++) {
            d[i] = d[i - 1] + d[i - 2];
        }

        System.out.println(d[n]);
    }
}
```
```java
12586269025
```

</div>
</details>
<br>

</div>
</details>
<br>

<details>
<summary>문제 예시 1 : 개미 전사, 식량창고 털기</summary>
<div markdown="1">
<br>

### 개미 전사
- 개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 식량창고는 일직선으로 이어져 있다.
- 각 식량창고에는 정해진 수의 식량을 저장하고 있으며, 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 인접한 식량창고가 공격받으면 바로 알아챌 수 있다.
- 따라서 개미 전사가 정찰벼에게 들키지않고 식량창고를 약탈하기 위해서는 `최소한 한칸 이상 떨어진 식량창고를 약탈`해야 한다.

  <img width="600px" src="https://user-images.githubusercontent.com/60170616/127125270-21abe8e4-b9da-4b6f-b177-e399421cb58b.JPG">

  |입력 예시|출력 예시|
  |-|-|
  |4<br/>1 3 1 5|8|
<br>

- 이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다.
- 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때, 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하세요.
<br>

### 문제 해결 아이디어
- i 번째 창고를 털 경우와 털지 않을 경우로 생각
  - i 번째 창고를 털 경우 : i-2 번째 창고까지 턴 경우 중 최대값 + i 번째 창고
  - i 번째 창고를 털지 않을 경우 : i-1 번째 창고까지 턴 경우 중 최댓값
<br>

<details>
<summary>Python 소스 코드</summary>
<div markdown="1">
<br>

```python
# 정수 N을 입력 받기
n = int(input())

# 모든 식량 정보 입력 받기
array = list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 다이나믹 프로그래밍 진행 (바텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])

for i in range(2, n):
    d[i] = max(d[i - 1], d[i - 2] + array[i])

# 계산된 결과 출력
print(d[n - 1])
```
```python
> 4
> 1 3 1 5
8
```
</div>
</details>
<br>

<details>
<summary>Java 소스 코드</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    // 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 
    public static int[] d = new int[100];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 정수 N을 입력받기
        int n = sc.nextInt();

        // 모든 식량 정보 입력받기
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        
        // 다이나믹 프로그래밍 진행(바텀업)
        d[0] = arr[0];
        d[1] = Math.max(arr[0], arr[1]);

        for (int i = 2; i < n; i++) {
            d[i] = Math.max(d[i - 1], d[i - 2] + arr[i]);
        }

        // 계산된 결과 출력
        System.out.println(d[n - 1]);
    }
}
```
```java
> 4
> 1 3 1 5
8
```
</div>
</details>
<br>

</div>
</details>
<br>

<details>
<summary>문제 예시 2 : 1로 만들기</summary>
<div markdown="1">
<br>

### 1로 만들기
- 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
  1. X가 5로 나누어 떨어지면, 5로 나눕니다.
  2. X가 3으로 나누어 떨어지면, 3으로 나눕니다.
  3. X가 2로 나누어 떨어지면, 2로 나눕니다.
  4. X에서 1을 뺍니다.
- 예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값입니다.
  - 26 -> 25 -> 5 -> 1
<br>

  |입력 예시|출력 예시|
  |-|-|
  |26|3|
<br>

### 문제 해결 아이디어
- 4가지 연산 각각의 경우에 다이나믹 프로그래밍을 적용한다.
- 점화식 :  
<img width="500px" src="https://user-images.githubusercontent.com/60170616/127127557-51a857e4-5526-4d0f-a3bd-528d20bee688.JPG">
<br>

<details>
<summary>Python 소스 코드</summary>
<div markdown="1">
<br>

```python
# 정수 X를 입력 받기
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 1000001

# 다이나믹 프로그래밍 진행(바텀업)
for i in range(2, x + 1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i - 1] + 1

    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)

    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)

    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print(d[x])
```
```python
> 26
3
```
</div>
</details>
<br>

<details>
<summary>Java 소스 코드</summary>
<div markdown="1">
<br>

```java
import java.util.*;

public class Main {
    // 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화 
    public static int[] d = new int[30001];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int x = sc.nextInt();

        // 다이나믹 프로그래밍 진행(바텀업)
        for (int i = 2; i <= x; i++) {
            // 현재의 수에서 1을 빼는 경우
            d[i] = d[i - 1] + 1;

            // 현재의 수가 2로 나누어 떨어지는 경우
            if (i % 2 == 0)
                d[i] = Math.min(d[i], d[i / 2] + 1);

            // 현재의 수가 3으로 나누어 떨어지는 경우
            if (i % 3 == 0)
                d[i] = Math.min(d[i], d[i / 3] + 1);

            // 현재의 수가 5로 나누어 떨어지는 경우
            if (i % 5 == 0)
                d[i] = Math.min(d[i], d[i / 5] + 1);
        }

        System.out.println(d[x]);
    }
}
```
```java
> 26
3
```
</div>
</details>
<br>

</div>
</details>

___
## 최단 경로 알고리즘
<br>

- 가장 짧은 경로를 찾는 알고리즘
  - 한 지점에서 다른 한 지점까지의 최단 경로
  - 한 지점에서 다른 모든 지점까지의 최단 경로
  - 모든 지점에서 다른 모든 지점까지의 최단 경로  
<img width="550px" src="https://user-images.githubusercontent.com/60170616/127328296-61e67ae1-e633-4650-b089-2db79ee78a63.JPG">
<br>

<details>
<summary>다익스트라 최단 경로 알고리즘</summary>
<div markdown="1">
<br>

- 특정 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산.
- 음의 간선이 없을 때 정삭적으로 동작
- 그리디 알고리즘으로 분류
<br>

### 알고리즘 동작 과정
1. 출발 노드 설정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5. 3번과 4번을 반복
<br>

<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328300-ffb70687-65c5-40f4-a566-68e8002ff59e.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328302-31686b9e-14b7-4d5e-a799-e937c3d89966.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328304-bbeee561-b489-4cec-8173-1d13c5fdc9fe.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328306-3509d5b2-dc51-41b1-806a-4d0fec06b6a3.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328308-82969f49-0988-4e8f-9b8e-f29ff0a25eab.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328311-4fce6cc2-c832-44ad-a4d7-3ef1df0db1c8.JPG">  
<br>

### 다익스트라 알고리즘의 특징
- 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택(그리디 알고리즘)
- `한 번 처리된 노드의 최단 거리는 고정`되어 바뀌지 않음
  - 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것
<br>

### 알고리즘 성능
- V = 노드의 개수
- 총 O(V)번에 걸쳐 최단 거리가 가장 짧은 노드를 매번 선형 탐색
- 시간 복잡도 : O(V²)
- 일반적으로 전체 노드의 개수가 5,000개 이하라면 문제를 해결할 수 있지만,  
  노드의 개수가 10,000개를 넘어가는 문제라면 더 효율적인 방법이 필요하다.

</div>
</details>
<br>

<details>
<summary>우선순위 큐를 활용한 효율적인 다익스트라 최단 경로 알고리즘</summary>
<div markdown="1">
<br>

- 우선순위가 가장 높은 데이터를 가장 먼저 삭제
- 우선순위 큐를 구현하기 위해 힙 자료구조를 사용
- 최소 힙 : 값이 낮은 데이터부터 꺼내는 방식  
  최대 힙 : 값이 높은 데이터부터 꺼내는 방식  

  |우선순위 큐 구현 방식|삽입 시간|삭제 시간|
  |:-------------------:|:-------:|:-------:|
  |리스트 |O(1)    |O(N)|
  |힙     |O(logN) |O(logN)|

- 현재 가장 가까운 노드를 저장해 놓기 위해서 힙 자료구조를 추가적으로 이용
- 현재의 최단 거리가 가장 짧은 노드를 선택해야 하므로 최소 힙 사용
<br>

### 알고리즘 동작 과정
<br>

<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328314-17303ff5-53b8-414c-8669-223fed0a7a3d.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328316-a80d5913-9a8b-4546-bbb5-108b74b3192c.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328317-e78e52e2-07be-4e9d-b0a6-ec53dac59cc7.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328319-4ef1d7ee-7357-4afc-881e-c182de8df56c.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328322-58cc3492-f7de-4f6f-b238-9f19135f4df1.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328327-58d2f8da-4295-43f3-8e70-7ddbefdcf1b7.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328330-4c7d4110-26de-434c-a2ae-fa0eab580936.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127328333-fed11912-9772-41ba-9a2f-4674a05af387.JPG">  
<br>

### 알고리즘 성능
- E = 간선의 개수  
  V = 노드의 개수
- 시간복잡도 : O(ElogE) = O(ElogV²) = O(2ElogV) = O(ElogV)
<br>

<details>
<summary>Python 다익스트라 알고리즘 구현(우선순위 큐 사용)</summary>
<div markdown="1">
<br>

```python
import heapq
import sys

input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())

# 시작 노드 번호를 입력받기
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]

# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c = map(int, input().split())

    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))

def dijkstra(start):
    q = []

    # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
    heapq.heappush(q, (0, start))
    distance[start] = 0

    while q: # 큐가 비어있지 않다면
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)

        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue

        # 현재 노드와 연결된 다른 인접한 노드들을 확인
        for i in graph[now]:
            cost = dist + i[1]

            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

# 다익스트라 알고리즘을 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    # 도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```

</div>
</details>
<br>

<details>
<summary>Java 다익스트라 알고리즘 구현(우선순위 큐 사용)</summary>
<div markdown="1">
<br>

```java
import java.util.*;

class Node implements Comparable<Node> {
    private int index;
    private int distance;

    public Node(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    public int getIndex() {
        return this.index;
    }

    public int getDistance() {
        return this.distance;
    }

    // 거리(비용)가 짧은 것이 높은 우선순위를 가지도록 설정
    @Override
    public int compareTo(Node other) {
        if (this.distance < other.distance) {
            return -1;
        }
        return 1;
    }
}

public class Main {
    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정

    // 노드의 개수(N), 간선의 개수(M), 시작 노드 번호(Start)
    // 노드의 개수는 최대 100,000개라고 가정
    public static int n, m, start;

    // 각 노드에 연결되어 있는 노드에 대한 정보를 담는 배열
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();

    // 최단 거리 테이블 만들기
    public static int[] d = new int[100001];

    public static void dijkstra(int start) {
        PriorityQueue<Node> pq = new PriorityQueue<>();

        // 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
        pq.offer(new Node(start, 0));
        d[start] = 0;

        while(!pq.isEmpty()) { // 큐가 비어있지 않다면
            // 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
            Node node = pq.poll();
            int dist = node.getDistance(); // 현재 노드까지의 비용 
            int now = node.getIndex(); // 현재 노드

            // 현재 노드가 이미 처리된 적이 있는 노드라면 무시
            if (d[now] < dist) continue;

            // 현재 노드와 연결된 다른 인접한 노드들을 확인
            for (int i = 0; i < graph.get(now).size(); i++) {
                int cost = d[now] + graph.get(now).get(i).getDistance();
                // 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
                if (cost < d[graph.get(now).get(i).getIndex()]) {
                    d[graph.get(now).get(i).getIndex()] = cost;
                    pq.offer(new Node(graph.get(now).get(i).getIndex(), cost));
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        m = sc.nextInt();
        start = sc.nextInt();

        // 그래프 초기화
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<Node>());
        }
        
        // 모든 간선 정보를 입력받기
        for (int i = 0; i < m; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();

            // a번 노드에서 b번 노드로 가는 비용이 c라는 의미
            graph.get(a).add(new Node(b, c));
        }

        // 최단 거리 테이블을 모두 무한으로 초기화
        Arrays.fill(d, INF);
        
        // 다익스트라 알고리즘을 수행
        dijkstra(start);

        // 모든 노드로 가기 위한 최단 거리를 출력
        for (int i = 1; i <= n; i++) {
            // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
            if (d[i] == INF) {
                System.out.println("INFINITY");
            }
            // 도달할 수 있는 경우 거리를 출력
            else {
                System.out.println(d[i]);
            }
        }
    }
}
```

</div>
</details>

</div>
</details>
<br>

<details>
<summary>플로이드 워셜 알고리즘</summary>
<div markdown="1">
<br>

- 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산
- 2차원 테이블에 최단 거리 정보를 저장
- 다이나믹 프로그래밍 유형에 속함
- 각 단계마다 특정한 노드 k를 거쳐 가는 경우를 확인
  - a에서 b로 가는 최단 거리보다 a에서 k를 거쳐 b로 가는 거리가 더 짧은지 검사
- 점화식  
  <img width="350px" src="https://user-images.githubusercontent.com/60170616/127330993-1de037b4-a91b-4802-92f6-f01330d09eaa.JPG">
<br>

### 알고리즘 동작 과정
<br>
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127330976-5f47013e-6ee0-41a7-8794-ae751fc7a814.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127330983-ea3d20a1-4a1e-4629-a13e-8d9d6d4a55b9.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127330986-93c4e8fe-4596-4dcd-b091-25ef7ac16e0a.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127330988-801bba21-1fab-40d1-8893-a3f82225c420.JPG">

##
<img width="700px" src="https://user-images.githubusercontent.com/60170616/127330992-ecd6abd9-1c88-4e4f-8bf8-bf32798f2800.JPG">
<br>

### 알고리즘 성능
- 노드의 개수가 N개일 때, 알고리즘상 N번의 단계를 수행
- 각 단계마다 O(N²)의 연산을 통해 현재 노드를 거쳐 가는 모든 경로를 고려
- 따라서 플로이드 워셜 알고리즘의 총 시간 복잡도는 O(N³)
<br>

<details>
<summary>Python 플로이드 워셜 알고리즘 구현</summary>
<div markdown="1">

```python
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수 및 간선의 개수를 입력받기
n = int(input())
m = int(input())

# 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n + 1) for _ in range(n + 1)]

# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 설정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘을 수행
for k in range(1, n + 1):
    for a in range(1, n + 1):
        for b in range(1, n + 1):
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

# 수행된 결과를 출력
for a in range(1, n + 1):
    for b in range(1, n + 1):
        # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
        if graph[a][b] == 1e9:
            print("INFINITY", end=" ")
        # 도달할 수 있는 경우 거리를 출력
        else:
            print(graph[a][b], end=" ")

    print()
```

</div>
</details>
<br>

<details>
<summary>Java 플로이드 워셜 알고리즘 구현</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
    public static final int INF = (int) 1e9; // 무한을 의미하는 값으로 10억을 설정

    // 노드의 개수(N), 간선의 개수(M)
    // 노드의 개수는 최대 500개라고 가정
    public static int n, m;

    // 2차원 배열(그래프 표현)를 만들기
    public static int[][] graph = new int[501][501];

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();
        m = sc.nextInt();

        // 최단 거리 테이블을 모두 무한으로 초기화
        for (int i = 0; i < 501; i++) {
            Arrays.fill(graph[i], INF);
        }

        // 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                if (a == b) graph[a][b] = 0;
            }
        }

        // 각 간선에 대한 정보를 입력 받아, 그 값으로 초기화
        for (int i = 0; i < m; i++) {
            // A에서 B로 가는 비용은 C라고 설정
            int a = sc.nextInt();
            int b = sc.nextInt();
            int c = sc.nextInt();
            graph[a][b] = c;
        }

        // 점화식에 따라 플로이드 워셜 알고리즘을 수행
        for (int k = 1; k <= n; k++) {
            for (int a = 1; a <= n; a++) {
                for (int b = 1; b <= n; b++) {
                    graph[a][b] = Math.min(graph[a][b], graph[a][k] + graph[k][b]);
                }
            }
        }

        // 수행된 결과를 출력
        for (int a = 1; a <= n; a++) {
            for (int b = 1; b <= n; b++) {
                // 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
                if (graph[a][b] == INF) {
                    System.out.print("INFINITY ");
                }
                // 도달할 수 있는 경우 거리를 출력
                else {
                    System.out.print(graph[a][b] + " ");
                }
            }

            System.out.println();
        }
    }
}
```

</div>
</details>

</div>
</details>

___
# 소수(Prime Number)
<br>

- 1보다 큰 자연수 중에서 1과 자기자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수(ex. 1, 2, 3, 5, 7, ⋯)
- 2부터 X의 제곱근까지의 모든 자연수에 대하여 연산을 수행

<br>
<details>
<summary>Python 소수 판별 알고리즘 구현</summary>
<div markdown="1">
<br>

```python
import math

# 소수 판별 함수
def is_prime_number(x):
    # 2부터 x의 제곱근까지의 모든 수를 확인하며
    for i in range(2, int(math.sqrt(x)) + 1):
        # x가 해당 수로 나누어떨어진다면
        if x % i == 0:
            return False # 소수가 아님
    return True # 소수임

print(is_prime_number(4)) # 4는 소수가 아님
print(is_prime_number(7)) # 7은 소수임
```
```python
False
True
```

</div>
</details>
<br>

<details>
<summary>Java 소수 판별 알고리즘 구현</summary>
<div markdown="1">
<br>

```java
import java.util.*;

class Main {
    // 소수 판별 함수(2이상의 자연수에 대하여)
    public static boolean isPrimeNumber(int x) {
        // 2부터 x의 제곱근까지의 모든 수를 확인하며
        for (int i = 2; i <= Math.sqrt(x); i++) {
            // x가 해당 수로 나누어떨어진다면
            if (x % i == 0) {
                return false; // 소수가 아님
            }
        }
        return true; // 소수임
    }

    public static void main(String[] args) {
        System.out.println(isPrimeNumber(4));
        System.out.println(isPrimeNumber(7));
    }
}
```
```java
False
True
```

</div>
</details>
<br>

### 에라토스테네스의 체 알고리즘
- 특정 범위안에 존재하는 모든 소수를 찾아야 할 때 사용
- 다수의 자연수에 대하여 소수 여부를 판별
- 시간복잡도 : O(NloglogN)
- 메모리가 많이 필요함

<br>
<details>
<summary>알고리즘 동작 과정</summary>
<div markdown="1">
<br>

1. 2부터 N까지의 모든 자연수를 나열
2. 남은수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾음
3. 남은수 중에서 i의 배수를 모두 제거(i는 제거하지 않음)
4. 더 이상 반복할 수 없을 때까지 2번과 3번 반복
<br>

<img width="600px" src="https://user-images.githubusercontent.com/60170616/127742881-9f46978c-32f9-497d-9ef1-c4591ccd7903.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/127742883-c0f3eb74-c450-4aee-a568-3ced59bf49e2.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/127742884-333dad33-fbbd-4449-9216-2f9324330f89.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/127742885-4f0806e0-6173-4a32-a719-58b534e92d59.JPG">

##
<img width="600px" src="https://user-images.githubusercontent.com/60170616/127742886-6dd20197-594c-4bad-b2ec-cda2a7ce7f11.JPG">
<br>
<details>
<summary>Python 에라토스테네스의 체 알고리즘 구현</summary>
<div markdown="1">
<br>

```python
import math

n = 100 # 2부터 100까지의 모든 수에 대하여 소수 판별
array = [True for i in range(n + 1)] # 처음엔 모든 수가 소수(True)인 것으로 초기화

# 에라토스테네스의 체 알고리즘
for i in range(2, int(math.sqrt(n)) + 1): # 2부터 n의 제곱근까지의 모든 수를 확인
    if array[i] == True: # i가 소수인 경우 (남은 수인 경우)
        # i를 제외한 i의 모든 배수를 지우기
        j = 2 
        while i * j <= n:
            array[i * j] = False
            j += 1

# 모든 소수 출력
for i in range(2, n + 1):
    if array[i]:
        print(i, end=' ')
```
```python
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

</div>
</details>
<br>

<details>
<summary>Java 에라토스테네스의 체 알고리즘 구현</summary>
<div markdown="1">
<br>

```java
import java.util.*;

class Main {
    public static int n = 100; // 2부터 100까지의 모든 수에 대하여 소수 판별
    public static boolean[] arr = new boolean[n + 1];

    public static void main(String[] args) {
        Arrays.fill(arr, true); // 처음엔 모든 수가 소수(True)인 것으로 초기화(0과 1은 제외)
        // 에라토스테네스의 체 알고리즘 수행
        // 2부터 n의 제곱근까지의 모든 수를 확인
        for (int i = 2; i <= Math.sqrt(n); i++) {
            // i가 소수인 경우(남은 수인 경우)
            if (arr[i] == true) {
                // i를 제외한 i의 모든 배수를 지우기
                int j = 2;
                while (i * j <= n) {
                    arr[i * j] = false;
                    j += 1;
                }
            }
        }
        // 모든 소수 출력
        for (int i = 2; i <= n; i++) {
            if (arr[i]) System.out.print(i + " ");
        }
    }
}
```
```java
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
```

</div>
</details>

</div>
</details>

___

___
# 코딩테스트 관련 정리
<br>

## 목차
  - [그리디 알고리즘](#그리디-알고리즘)
  - [구현 문제](#구현-문제)
  - [스택 구현 (Python & Java)](#스택-구현python--java)
  - [큐 구현 (Python & Java)](#큐-구현python--java)
  - [재귀 함수](#재귀-함수)
    - 팩토리얼 구현
    - 최대공약수 구현
  - [DFS (Python & Java)](#dfs-depth-first-search)
  - [BFS (Python & Java)](#bfs-breadth-first-search)
  - [정렬 알고리즘](#정렬-알고리즘)
    - 알고리즘 비교(선택, 삽입, 퀵, 계수)
    - 퀵 정렬(상세 과정 & 구현)
    - 계수 정렬(상세 과정 & 구현)
___
<br>

## 그리디 알고리즘
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 정당성 분석 중요
  - 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
___
<br>

## 구현 문제
- 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제
  - 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
  - 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
  - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
  - 적절한 라이브러리를 찾아서 사용해야 하는 문제
___
<br>

## 스택 구현(Python & Java)
<details>
<summary>Python 스택 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
# python은 따로 라이브러리가 필요하지 않음
stack = []

stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(4)

print(stack[::-1]) # 최상단 원소부터 출력
print(stack) # 최하단 원소부터 출력
```
```python
[4, 3, 2, 5]
[5, 2, 3, 4]
```

</div>
</details>
<br>

<details>
<summary>Java 스택 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Stack<Integer> s = new Stack<>();

    s.push(5);
    s.push(2);
    s.push(3);
    s.push(7);
    s.pop();
    s.push(4);

    // 스택의 최상단 원소부터 출력
    while (!s.empty()) {
      System.out.print(s.peek() + "");
      s.pop();
    }
  }
}
```
```java
4 3 2 5
```

</div>
</details>

___
<br>

## 큐 구현(Python & Java)

<details>
<summary>Python 큐 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
# list로 바로 구현 가능하지만 시간 복잡도가 높아서 deque 라이브러리 사용 추천
from collections import deque

queue = deque()

queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(4)
queue.append(1)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 역순으로 바꾸기
print(queue) # 나중에 들어온 순서대로 출력
```
```python
deque([3, 7, 4, 1])
deque([1, 4, 7, 3])
```

</div>
</details>
<br>

<details>
<summary>Java 큐 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Queue<Integer> q = new LinkedList<>();

      q.offer(5);
      q.offer(2);
      q.offer(3);
      q.offer(7);
      q.poll();
      q.offer(4);
      q.offer(1);
      q.poll();

    // 먼저 들어온 원소부터 추출
    while (!q.isEmpty()) {
      System.out.print(q.poll() + "");
    }
  }
}
```
```java
3 7 4 1
```

</div>
</details>

___
<br>

## 재귀 함수
- 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있다.
  - 하지만 오히려 다른 사람이 이해하기 어려운 형태의 코드가 될 수 있습니다.
- 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓입니다.
  - 그래서 스택을 사용해야 할 때 구현상 스택 라이브러리 대신 재귀 함수를 이용하는 경우가 많습니다.
<br>

<details>
<summary>
  팩토리얼 구현 코드 (펼쳐보기)

  - n! = 1 x 2 x 3 x ⋯ x (n-1) x n
  - 0! = 1! = 1
</summary>
<div markdown="1">

```python
# 반복적으로 구현한 n!
def factorial_iterative(n):
  result = 1

  # 1부터 n까지의 수를 차례대로 곱하기
  for i in range(1, n+1):
    result *= i
  
  return result


# 재귀적으로 구현한 n!
def factorial_recursive(n):
  # n이 1 이하인 경우 1을 반환
  if n <= 1:
    return 1
  
  # n! = n * (n-1)!
  return n * factorial_recursive(n-1)

print('반복적으로 구현 결과 :', factorial_iterative(5))
print('재귀적으로 구현 결과 :', factorial_recursive(5))
```
```python
반복적으로 구현 결과 : 120
재귀적으로 구현 결과 : 120
```

</div>
</details>
<br>

<details>
<summary>최대 공약수 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
def gcd(a, b):
  if a % b == 0:
    return b
  else:
    return gcd(b, a% b)

print(gcd(192, 162))
```
```python
6
```

</div>
</details>

___
<br>

## DFS (Depth-First Search)
- 깊이 우선 탐색
- 깊은 부분을 우선적으로 탐색하는 알고리즘
- 스택 자료구조(혹은 재귀 함수)를 이용
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 합니다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리합니다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
<br>

<img width="750px" src="https://user-images.githubusercontent.com/60170616/126313861-318f5067-b388-4d67-85d1-d89d29748919.png">
<br>

<details>
<summary>Python DFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
# DFS 함수 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```
```python
1 2 7 6 8 3 4 5
```

</div>
</details>
<br>

<details>
<summary>Java DFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
    public static boolean[] visited = new boolean[9];
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();

    // DFS 함수 정의
    public static void dfs(int x) {
        // 현재 노드를 방문 처리
        visited[x] = true;
        System.out.print(x + " ");

        // 현재 노드와 연결된 다른 노드를 재귀적으로 방문
        for (int i = 0; i < graph.get(x).size(); i++) {
            int y = graph.get(x).get(i);
            if (!visited[y]) dfs(y);
        }
    }

    public static void main(String[] args) {
        // 그래프 초기화
        for (int i = 0; i < 9; i++) {
            graph.add(new ArrayList<Integer>());
        }

        // 노드 1에 연결된 노드 정보 저장 
        graph.get(1).add(2);
        graph.get(1).add(3);
        graph.get(1).add(8);
        
        // 노드 2에 연결된 노드 정보 저장 
        graph.get(2).add(1);
        graph.get(2).add(7);
        
        // 노드 3에 연결된 노드 정보 저장 
        graph.get(3).add(1);
        graph.get(3).add(4);
        graph.get(3).add(5);
        
        // 노드 4에 연결된 노드 정보 저장 
        graph.get(4).add(3);
        graph.get(4).add(5);
        
        // 노드 5에 연결된 노드 정보 저장 
        graph.get(5).add(3);
        graph.get(5).add(4);
        
        // 노드 6에 연결된 노드 정보 저장 
        graph.get(6).add(7);
        
        // 노드 7에 연결된 노드 정보 저장 
        graph.get(7).add(2);
        graph.get(7).add(6);
        graph.get(7).add(8);
        
        // 노드 8에 연결된 노드 정보 저장 
        graph.get(8).add(1);
        graph.get(8).add(7);

        dfs(1);
    }
}
```
```java
1 2 7 6 8 3 4 5
```

</div>
</details>

___
<br>

## BFS (Breadth-First Search)
- 너비 우선 탐색
- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- 최단 거리를 구할 때 사용 가능
- 큐 자료구조를 이용
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 바문 처리합니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
<br>

<img width="750px" src="https://user-images.githubusercontent.com/60170616/126315610-08595bdf-72b5-4573-8a6e-6b7086e8aa1b.JPG">
<br>

<details>
<summary>Python BFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
from collections import deque

# BFS 함수 정의
def bfs(graph, start, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])

    # 현재 노드를 방문 처리
    visited[start] = True

    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        print(v, end=' ')

        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)
```
```python
1 2 3 8 7 4 5 6
```

</div>
</details>
<br>

<details>
<summary>Java BFS 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
    public static boolean[] visited = new boolean[9];
    public static ArrayList<ArrayList<Integer>> graph = new ArrayList<ArrayList<Integer>>();

    // BFS 함수 정의
    public static void bfs(int start) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);

        // 현재 노드를 방문 처리
        visited[start] = true;

        // 큐가 빌 때까지 반복
        while(!q.isEmpty()) {
            // 큐에서 하나의 원소를 뽑아 출력
            int x = q.poll();
            System.out.print(x + " ");

            // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
            for(int i = 0; i < graph.get(x).size(); i++) {
                int y = graph.get(x).get(i);
                if(!visited[y]) {
                    q.offer(y);
                    visited[y] = true;
                }
            }
        }
    }

    public static void main(String[] args) {
        // 그래프 초기화
        for (int i = 0; i < 9; i++) {
            graph.add(new ArrayList<Integer>());
        }

        // 노드 1에 연결된 노드 정보 저장 
        graph.get(1).add(2);
        graph.get(1).add(3);
        graph.get(1).add(8);
        
        // 노드 2에 연결된 노드 정보 저장 
        graph.get(2).add(1);
        graph.get(2).add(7);
        
        // 노드 3에 연결된 노드 정보 저장 
        graph.get(3).add(1);
        graph.get(3).add(4);
        graph.get(3).add(5);
        
        // 노드 4에 연결된 노드 정보 저장 
        graph.get(4).add(3);
        graph.get(4).add(5);
        
        // 노드 5에 연결된 노드 정보 저장 
        graph.get(5).add(3);
        graph.get(5).add(4);
        
        // 노드 6에 연결된 노드 정보 저장 
        graph.get(6).add(7);
        
        // 노드 7에 연결된 노드 정보 저장 
        graph.get(7).add(2);
        graph.get(7).add(6);
        graph.get(7).add(8);
        
        // 노드 8에 연결된 노드 정보 저장 
        graph.get(8).add(1);
        graph.get(8).add(7);

        bfs(1);
    }
}
```
```java
1 2 3 8 7 4 5 6
```

</div>
</details>

___
<br>

## 정렬 알고리즘
- 알고리즘 비교(선택, 삽입, 퀵, 계수)

|정렬 알고리즘| 평균 시간 복잡도| 공간 복잡도| 특징|
|:-----------:|:---------------:|:----------:|-----|
|선택 정렬| O(N²)| O(N)| 아이디어가 간단함|
|삽입 정렬| O(N²)| O(N)| 데이터가 거의 정렬되어 있을때 가장 빠름|
|퀵 정렬| O(NlogN)| O(N)| 대부분의 경우에 적합, 충분히 빠름|
|계수 정렬| O(N+K)| O(N+K)| 데이터의 크기가 한정되어 있는 경우에 적합, 매우 빠름|
<br>

<details>
<summary>퀵 정렬 상세 과정 (펼쳐보기)</summary>
<div markdown="1">

- 기준 데이터(피벗)을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방식의 정렬
1. 피벗 설정,  
왼쪽부터 피벗보다 큰 데이터 선택,  
오른쪽부터 피벗보다 작은 데이터 선택  
두 개의 데이터 위치 변경,  
계속 반복  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126790023-9b810bd2-a8ce-43f4-b70c-781635aa9fb5.JPG">
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126790024-fde1828b-44f9-4292-9038-cdca73162708.JPG">

2. 큰 데이터와 작은 데이터의 위치가 엇갈리는 경우, 피벗과 작은 데이터의 위치 변경  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791094-99ce7c3a-e74f-4850-83a4-559d96e6f395.JPG">

3. 피벗을 기준으로 데이터 묶음을 분할  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791099-10b5b4db-14d8-4575-a950-dba262c3f698.JPG">

4. 왼쪽 데이터 묶음 퀵 정렬,  
오른쪽 데이터 묶음 퀵 정렬,  
반복  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791101-1d9fcb35-c366-4d6f-b7aa-1ebf63c10558.JPG">
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126791104-be5f5ddb-6d56-42a0-9bc5-366f423c6454.JPG">

</div>
</details>
<br>

<details>
<summary>Python 퀵 정렬 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while(left <= right):
        # 피벗보다 큰 데이터를 찾을 때까지 반복 
        while(left <= end and array[left] <= array[pivot]):
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while(right > start and array[right] >= array[pivot]):
            right -= 1
        if(left > right): # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
```
```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
<br>

- 파이썬의 장점을 살린 간결한 코드
```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array

    pivot = array[0] # 피벗은 첫 번째 원소
    tail = array[1:] # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```
```python
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

</div>
</details>
<br>

<details>
<summary>Java 퀵 정렬 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
    public static void quickSort(int[] arr, int start, int end) {
        if (start >= end) return; // 원소가 1개인 경우 종료
        int pivot = start; // 피벗은 첫 번째 원소
        int left = start + 1;
        int right = end;
        while (left <= right) {
            // 피벗보다 큰 데이터를 찾을 때까지 반복
            while (left <= end && arr[left] <= arr[pivot]) left++;
            // 피벗보다 작은 데이터를 찾을 때까지 반복
            while (right > start && arr[right] >= arr[pivot]) right--;
            // 엇갈렸다면 작은 데이터와 피벗을 교체
            if (left > right) {
                int temp = arr[pivot];
                arr[pivot] = arr[right];
                arr[right] = temp;
            }
            // 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            else {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
            }
        }
        // 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
        quickSort(arr, start, right - 1);
        quickSort(arr, right + 1, end);
    }

    public static void main(String[] args) {
        int n = 10;
        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

        quickSort(arr, 0, n - 1);

        for(int i = 0; i < n; i++) {
            System.out.print(arr[i] + " ");
        }
    }
}
```
```java
0 1 2 3 4 5 6 7 8 9
```

</div>
</details>
<br>

<details>
<summary>계수 정렬 상세 과정 (펼쳐보기)</summary>
<div markdown="1">

- 동일한 값의 데이터가 여러 개 등장할 때 효율적일 것(ex. 시험 성적)

1. 가장 작은 데이터부터 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트 생성
2. 데이터를 하나씩 확인하여 count 1씩 증가
3. count 값 만큼 인덱스 값을 반복 출력  
<img width="650px" src="https://user-images.githubusercontent.com/60170616/126797204-9a7b60c5-841e-44ca-b627-ca9eba5606c7.JPG">

</div>
</details>
<br>

<details>
<summary>Python 계수 정렬 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): # 리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end=' ') # 띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
```
```python
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
```

</div>
</details>
<br>

<details>
<summary>Java 계수 정렬 구현 코드 (펼쳐보기)</summary>
<div markdown="1">

```java
import java.util.*;

public class Main {
    public static final int MAX_VALUE = 9;

    public static void main(String[] args) {
        int n = 15;
        // 모든 원소의 값이 0보다 크거나 같다고 가정
        int[] arr = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};
        // 모든 범위를 포함하는 배열 선언(모든 값은 0으로 초기화)
        int[] cnt = new int[MAX_VALUE + 1];

        for (int i = 0; i < n; i++) {
            cnt[arr[i]] += 1; // 각 데이터에 해당하는 인덱스의 값 증가
        }

        for (int i = 0; i <= MAX_VALUE; i++) { // 배열에 기록된 정렬 정보 확인
            for (int j = 0; j < cnt[i]; j++) {
                System.out.print(i + " "); // 띄어쓰기를 기준으로 등장한 횟수만큼 인덱스 출력
            }
        }
    }
}
```
```java
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
```

</div>
</details>
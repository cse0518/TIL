___

> ## ✨ Issue
> - `mock` 객체를 생성할 때, `static` 변수로 생성자 주입이 안되는 문제를 보고 static에 대하여 자세히 찾아봅니다.
> - 결론 : static은 유틸리티 함수를 만드는데 유용하고, 그 이외의 일반적인 경우에는 지양한다.
<br/>

# static
- static으로 지시된 특정한 멤버는 해당 클래스의 인스턴스가 아니라 클래스 자체에 속해 있다.
- 메모리에 한번 할당되어 프로그램이 종료될 때 해제된다.
<br/>
<img width="500px" src="https://t1.daumcdn.net/cfile/tistory/99AAAC405CEC82C032">

> - 일반적으로 생성된 **Class**는 **Static 영역**에 생성되고, new 연산을 통해 생성한 **객체**는 **Heap 영역**에 생성된다.
>   - Heap 영역의 메모리는 Garbage Collector를 통해 수시로 관리된다.
>   - static 영역에 할당된 메모리는 모든 객체가 공유하는 메모리라는 장점을 지닌다.
>       - 하지만 Garbage Collector의 관리 영역 밖에서 프로그램의 종료시까지 메모리가 할당된 채로 존재한다.
>       - 자주 사용하게 되면 시스템 퍼포먼스에 악영향을 준다.

- static 변수 특징
  - 클래스 변수
  - 객체를 생성하지 않고도 static 자원에 접근 가능
- static 메소드
  - 객체의 생성 없이 호출 가능
<br/>

## static의 사용을 '지양'한다
#### 1. 전체 프로그램과 동일한 라이프사이클
- static 멤버는 사용을 하던 사용하지 않던 프로그램의 시작과 끝까지 메모리 내에 존재한다.
#### 2. static 변수의 생성과 소멸을 지시할 수 없음
- 프로그램이 로딩될 때 생성되고, 프로그램이 종료되거나 JVM이 내려갈 때 소멸된다. 개발자가 프로그램적으로 생성과 소멸에 관여할 수 없다.
#### 3. thread safe하지 않음
- 프로그램 전역에서 사용되기 때문에 모든 스레드에서 static 필드를 공유하게 된다. 이때 한 스레드에서 값을 변경할 경우 다른 모든 스레드에서 영향을 받는다. 이는 동시성 문제를 야기한다.
#### 4. thread safe하게 만들기 위해 추가적인 작업 필요
- 전역으로 관리되기 때문에 기본적으로 thread safety하지 않으며, synchronize를 사용하여 이를 보장하기 위해서는 추가적인 작업이 필요하다.
#### 5. static 메서드는 오버라이딩 불가
#### 6. static 멤버는 Serialization 불가
- 객체 직렬화는 인스턴스에 대해 적용되기 때문에 클래스 자체 정보인 static 멤버는 여기에 포함되지 않는다.
#### 7. 런타임 다형성 불가
#### 8. 메모리 문제
- static 멤버는 프로그램이 종료될 때까지 Garbage Collector로 회수되지 않기 때문에, 많은 수의 static 필드나 메서드가 존재할 경우 메모리에 영향을 미친다. static 필드에 데이터가 계속해서 쌓이게 되면 OutOfMemory가 발생할 수도 있다.
#### 9.  테스트하기 어려움
- static 필드는 전역으로 관리되기 때문에 프로그램 전체에서 이 필드에 접근할 수 있고 변경할 수 있으므로 해당 필드를 추론하기 어려워 테스트하기가 까다롭다.
